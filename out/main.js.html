<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>JSDoc: Source: main.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link
      type="text/css"
      rel="stylesheet"
      href="styles/prettify-tomorrow.css"
    />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css" />
  </head>

  <body>
    <div id="main">
      <h1 class="page-title">Source: main.js</h1>

      <section>
        <article>
          <pre class="prettyprint source linenums"><code>/**
 * This function generates a random addition problem within the given parameters
 * @param maxResult Constrains the sum of the problem to be no larger than than this value
 * @param avoidCarryover (optional) Constrains the addends such that carry over is not necessary
 * @returns PlainText Math string for the generated problem
 */
export function generateAdditionProblem(maxResult, avoidCarryover = false) {
    let term1, term2, sum;
    // validations
    if (maxResult &lt; 1)
        throw 'Invalid max result for addition';
    do {
        sum = Math.floor(Math.random() * maxResult) + 1;
        term1 = Math.floor(Math.random() * sum) + 1;
        term2 = sum - term1; // could  be zero
    } while ((avoidCarryover &amp;&amp; hasCarryOver(term1, term2)) || sum > maxResult);
    return `${term1} + ${term2} = ${sum}`;
    function hasCarryOver(term1, term2) {
        let term1Array = Array.from(term1.toString()).map(Number);
        let term2Array = Array.from(term2.toString()).map(Number);
        for (let i = 1; i &lt; 1 + Math.min(term1Array.length, term2Array.length); i++) {
            let digit1 = term1Array[term1Array.length - i];
            let digit2 = term2Array[term2Array.length - i];
            if (digit1 + digit2 >= 10) {
                return true;
            }
        }
        return false;
    }
}
/**
 * This function generates a random multiplication problem within the given parameters
 * @param maxTerm Constrains the factor(s) of the problem to be no larger than this value
 * @param maxTerm2 (Optional) Constrains the second factor to be no larger than this value
 * @returns PlainText Math string for the generated problem
 */
export function generateMultiplicationProblem(maxTerm, maxTerm2 = -1) {
    let term1, term2, product;
    if (maxTerm2 == -1)
        maxTerm2 = maxTerm;
    term1 = Math.floor(Math.random() * (maxTerm - 1));
    term2 = Math.floor(Math.random() * maxTerm2);
    product = term1 * term2;
    return `${term1} * ${term2} = ${product}`;
}
/**
 * This function generates a random subtraction problem within the given parameters. The difference will not be less than zero.
 * @param maxTerm Constrains the minuend of the problem to be no larger than this value
 * @param maxTerm2 (optional) Constrains the subtrahend of the problem to be no larger than this value
 * @param avoidBorrowing (optional) Constrains the subtrahend such that borrowing is not necessary
 * @returns PlainText Math string for the generated problem
 */
export function generateSubtractionProblem(maxTerm, maxTerm2 = -1, avoidBorrowing = false) {
    let term1, term2, difference;
    if (maxTerm2 == -1)
        maxTerm2 = maxTerm;
    // validations
    if (maxTerm &lt; 0 || maxTerm2 &lt; 0)
        throw 'Invalid max term for substraction';
    do {
        term1 = Math.floor(Math.random() * maxTerm) + 1;
        let tmpMax = Math.min(maxTerm2, term1);
        term2 = Math.floor(Math.random() * tmpMax) + 1;
        difference = term1 - term2;
    } while (avoidBorrowing &amp;&amp; hasBorrowing(term1, term2));
    return `${term1} - ${term2} = ${difference}`;
    function hasBorrowing(term1, term2) {
        let term1Array = Array.from(term1.toString()).map(Number);
        let term2Array = Array.from(term2.toString()).map(Number);
        for (let i = 1; i &lt; term1Array.length + 1; i++) {
            let digit1 = term1Array[term1Array.length - i];
            let digit2 = term2Array[term2Array.length - i];
            if (digit1 &lt; digit2) {
                return true;
            }
        }
        return false;
    }
}
/**
 * This function generates a random division problem within the given parameters. The difference will not be imaginary.
 * @param maxDividend Constrains the dividen of the problem to be no larger than this value
 * @param avoidRemainder (optional) Constrains the divisor such that a remainder is not needed
 * @returns PlainText Math string for the generated problem
 */
export function generateDivisionProblem(maxDividend, avoidRemainder = false) {
    let term1, term2, quotient, remainder = 0;
    do {
        term1 = Math.floor(Math.random() * maxDividend) + 1;
        term2 = Math.floor(Math.random() * term1) + 1; // +1 here means we avoid divide by zero, subtracting 1 from the term means we avoid dividing a number by itself with result of 1 (except when the dividend itself is 1)
        quotient = term1 / term2;
    } while (avoidRemainder &amp;&amp; quotient != Math.floor(quotient));
    if (avoidRemainder) {
        return `${term1} / ${term2} = ${quotient}`;
    }
    // show remainder
    if (quotient != Math.floor(quotient)) {
        remainder = term1 % term2;
        quotient = Math.floor(quotient);
        return `${term1} / ${term2} = ${quotient} R${remainder}`;
    }
    else {
        return `${term1} / ${term2} = ${quotient}`;
    }
}
/**
 * This function generates a random problem set based on the generator functions passed in. It will try not to create duplicate problems, if at all possible. Note: Duplicate check is not based on canonical representation.
 * @param generators An array of one or more functions which generate problems
 * @param setSize The retryCount of unique problems to generate
 * @returns Array of PlainText Math strings for the generated problems
 */
export function generateProblemSet(generators, setSize) {
    let result = new Array();
    for (let i = 0; i &lt; setSize; i++) {
        let tmp;
        let retryCount = 0;
        // checks for duplicates and looks for another problem if so
        do {
            // choose a generator
            const generator = generators[Math.floor(Math.random() * generators.length)];
            tmp = generator();
            retryCount++;
        } while (result.includes(tmp) &amp;&amp; retryCount &lt; 5 * generators.length);
        result.push(tmp);
    }
    return result;
}
//# sourceMappingURL=main.js.map</code></pre>
        </article>
      </section>
    </div>

    <nav>
      <h2><a href="index.html">Home</a></h2>
      <h3>Global</h3>
      <ul>
        <li>
          <a href="global.html#generateAdditionProblem"
            >generateAdditionProblem</a
          >
        </li>
        <li>
          <a href="global.html#generateDivisionProblem"
            >generateDivisionProblem</a
          >
        </li>
        <li>
          <a href="global.html#generateMultiplicationProblem"
            >generateMultiplicationProblem</a
          >
        </li>
        <li><a href="global.html#generateProblemSet">generateProblemSet</a></li>
        <li>
          <a href="global.html#generateSubtractionProblem"
            >generateSubtractionProblem</a
          >
        </li>
      </ul>
    </nav>

    <br class="clear" />

    <footer>
      Documentation generated by
      <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Dec 10
      2023 17:59:28 GMT-0700 (Mountain Standard Time)
    </footer>

    <script>
      prettyPrint();
    </script>
    <script src="scripts/linenumber.js"></script>
  </body>
</html>
